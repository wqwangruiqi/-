mybatis特点
 用户提供参数和sql 剩下的就不管了  交给mybatis框架来做 实现数据的查询等操作
 sql写在哪里?
 	  1 xml提供    建议使用xml 
 	  2 注解提供   (如果sql修改 源码需要重新编译 复杂sql 拼接逻辑 注解很繁琐)
 	  
 如果实现dao接口？
  	1 mapper 自动 实现 dao接口    dao只需要设计接口 不需要实现类   建议使用mapper自动实现 (只写接口 不写实现)
  	2  api编程方式实现dao接口 	  
  注意:根据接口方法我们需要知道该方法作用 
  				Seckill queryById(long seckillId);
  				结果集			行为					参数
  				根据方法名可以知道 根据 id 获取对象 
  
  更少的配置---别名
  更少的配置---配置扫描  如果项目里面有很多的配置文件(xml) 文件  mybatis 可以自动扫描文件
  更少的配置---dao实现    
  足够的灵活性 自动定制sql 自动传参结果集自动复制
  xml提供sql  dao接口提供Mapper
  
  dao层工作为：接口设计+sql编写
  代码和sql分离 方便其他人(上级主管 DBA)等  查看我们的sql代码 
  
  逻辑处理程序(dao拼接等逻辑) 由Service层完成
  
  
  spring管理service依赖
	  spring ioc功能理解
	   对象工厂
	   依赖管理
	   最终给我们一个一致的访问接口
	   通过接口 可以拿到我们需要用到的对象
  	
  	业务对象依赖图
  	
  									|SeckilDao					|
  	SeckillService ---->| 									|---->SqlSessionFactory---->DataSource.......
  								  	|SuccessKilledDao		|
	为什么要用IOC
		对象创建统一托管
		规范的生命周期管理
		灵活的依赖注入(注解 xml配置等等)
		一直的获取对象方式
		
	Spring IOC注入方式和场景
	注入方式： 			xml   			注解   				JAVA配置类
	场景： xml  Bean实现类来之第三方类库 如:DataSource等;需要命名空间配置 如：context aop mvc config等
				注解：项目中自身开发使用的类 可直接在代码中使用注解 如：@Service, @Controller等
				java配置类：需要通过代码控制对象创建逻辑的场景 如:自定义修改依赖类库	  不常用
	IOC使用
	xml配置 --->  package-scan  ---> Annotation注解
	
	
	什么是声明式事务
		开启事务操作
		 	操作数据库1
		 	操作数据库2
			操作数据库3
		提交/回滚 事务
		
		声明式事务使用方式
		proxyFactoryBean +XML 			早期的使用方式2.0
		tx:advice+aop命名空间  				一次配置永久生效      很多人使用  但是很容易遗忘部分问题
		注解 @Transaction   					注解方式标注到方法上面    建议使用这种方式  其他人看见这个方法的注解时候 代表这个是一个事务方法 就回有很多的注意事项 优化分析什么的
		
		
		事务方法嵌套
			 声明式事务独有的概念
			 	传播行为的体现    默认行为propatation_required  意思是 当有一个新的事务加入进来的时候  如果有事务就直接加入到原有的事务 如果没有创建一个新的事务
		什么时候回滚事务
			当方法抛出运行期异常 (RuntimeException) 的时候 会执行回滚
			当方法抛出非运行期异常的时候 不会执行回滚  这个时候就会产生部分成功 部分失败  所以要小心不当的try-catch
		

系统相关课程
 1 前端交互设计
 2 Restful
 3 SpringMvc
 4 bootstrap + jquery
 
 前端交互设计
 	产品 ： 解读用户需求 设计满足用户需求的文档 前端 和后端能够根据文档开发
 	前端 ：设计前端交互
 	后端 ：数据交换等等
 	
 前端页面流程：
 	列表：展示所有的秒杀产品信息
 	详情页：用户点击产品进入详情页面
 				详情页有个判断：判断用户是否登录  用户已经登录就开始展示逻辑  用户未登录 弹出登录操作  用户提交登录 后 将用户信息写入cookie里面 会再次进入详情页面的战士逻辑当中
 				详情页展示流程逻辑：首先获取系统标准时间(服务器时间为准)   ----> 判断时间是否在合法秒杀时间内  ----> 时间大于结束时间则结束秒杀----->时间小于开始时间 则倒计时 ----> 倒计时结束 或者时间合法 会得到秒杀地址
 				用户根据秒杀地址可以执行秒杀 ---->执行秒杀后 后台返回秒杀结果
 	
 	
 	设计Restful接口：
 		本质上是一种优雅的URL表达式
 		意义是：资源状态和状态的转移
 		Restful规范：
 			get 		查询操作
 			post 	添加或修改操作
 			put 		修改操作
 			delete 	删除操作
 		URL设计：
 			/模块/资源/{标示}/集合
 		秒杀API的URL设计
	 		GET  	/seckill/list  秒杀列表
	 		GET 	/seckill/{id}/detail    详情页
	 		GET 	/seckill/time/now  获取系统时间
	 		POST 	/seckil/{id}/exposer  暴露秒杀地址
	 		POST	/seckill/{id}/{md5}/execution  执行秒杀
 		
 		
 	
 	
 	WEB端总结：
 		前端交互设计过程
 		Restful接口设计
 		SpringMVC使用技巧
 		Bootstraps和JS使用
 	
 	
 	CDN的理解
 		CDN(内容分发网络) 加速用户获取数据的系统
 		部署在离用户最近的网络节点
	 			
 
  项目高并发优化：
  	高并发发生点？
  		详情页---->用户大量刷新(可以将页面放在CDN缓存上面)
  		
		为什么要单独获取系统时间？
	
		秒杀地址接口分析
			无法使用CND缓存
		
  					
  			
		执行秒杀这个操作是高并发的地方
  		
  		
  		
  		
  		方案分析 高并发方案
  		
  		为什么不用mysql
  			
  		
  		
  		如何减少行级锁的时间
  		 		1优化方式:先记录购买明细 其次再减少库存 
				2深度优化：事务在mysql服务端 使用存储过程 （存储过程优化 事务行级锁持有的时间优化）
			注意：不要过度的依赖存储过程
						简单的逻辑可以应用存储过程(存储过程最常用市场：银行业务系统   很多逻辑放在数据库服务器使用存储过程执行)
				
  		
  		如果判断update更新库存成功
  			1 update自身没报错
  			2 客户端确认update影响记录数
  		优化思路：
  			把客户端逻辑放在mysql服务器端 避免网络延迟和GC的影响
  		解决方案：使用存储过程 整个事务在mysql端完成
  		
  		
  		优化总结
  			前端控制：暴露接口 按钮防重复提交
  			动静态的数据分离：CDN缓存(公司其他团队的工作)+后端缓存
  			事务竞争：减少事务锁时间
  			
  		
  		项目部署：
  			CDN:JS,CSS 静态页面等
  			WebService：Nginx+jetty
  			Redis:缓存
  			Mysql：数据库
  			
  			
  		部署架构：
  			
  			
  			tddl 分库分表 
  			
  			
  			
  		 项目回顾：
  		 	数据层：
  		 		数据库设计和实现
  		 		mybatis理解和使用
  		 		mybatis整合spring
  		 	业务层：
  		 		业务接口设计和封装
  		 		spring IOC配置
  		 		spring声明式事务使用
  		 	web层：
  		 		Restful接口运用
  		 		SpringMVC使用
  		 		前端交互分析
  		 		bootstrap+js使用
  		 	并发优化：
  		 		系统瓶颈点分析
  		 		事务、锁、网络延迟理解
  		 		前端、CDN、缓存等
  		 		集群化部署
  		 
  		 		
  			
  			
  		
  			
  			
  		
  		
  		
  		
  		
 
 		
 			
 
 
 
 
 


	 	
		
		
  	
  	